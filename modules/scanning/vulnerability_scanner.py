#!/usr/bin/env python3
"""
Vulnerability Scanner Module for HackSayer
Author: SayerLinux
Provides comprehensive vulnerability scanning capabilities
"""

import socket
import requests
import json
import time
import concurrent.futures
import threading
import subprocess
import re
from urllib.parse import urlparse, urljoin
from colorama import Fore, Style
import ssl
import hashlib

class VulnerabilityScanner:
    """Comprehensive vulnerability scanner"""
    
    def __init__(self):
        self.vulnerabilities = []
        self.lock = threading.Lock()
        self.user_agents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        ]
    
    def scan(self, target):
        """Run comprehensive vulnerability scan"""
        print(f"{Fore.GREEN}[SCAN] Starting vulnerability scan on {target}{Style.RESET_ALL}")
        
        self.vulnerabilities = []
        
        # Determine if target is IP or domain
        try:
            socket.inet_aton(target)
            is_ip = True
            base_url = f"http://{target}"
        except socket.error:
            is_ip = False
            base_url = f"https://{target}" if not target.startswith('http') else target
        
        # Run scanning phases
        with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
            futures = []
            
            # Web vulnerability scanning
            if not is_ip:
                futures.append(executor.submit(self.scan_web_vulnerabilities, base_url))
                futures.append(executor.submit(self.scan_sql_injection, base_url))
                futures.append(executor.submit(self.scan_xss, base_url))
                futures.append(executor.submit(self.scan_lfi, base_url))
                futures.append(executor.submit(self.scan_directory_traversal, base_url))
            
            # Network vulnerability scanning
            futures.append(executor.submit(self.scan_network_vulnerabilities, target))
            
            # SSL/TLS vulnerability scanning
            if not is_ip:
                futures.append(executor.submit(self.scan_ssl_vulnerabilities, target))
            
            # Service-specific scanning
            futures.append(executor.submit(self.scan_services, target))
            
            # Wait for all tasks to complete
            concurrent.futures.wait(futures)
        
        print(f"{Fore.GREEN}[SCAN] Found {len(self.vulnerabilities)} vulnerabilities{Style.RESET_ALL}")
        return self.vulnerabilities
    
    def scan_web_vulnerabilities(self, url):
        """Scan for web application vulnerabilities"""
        try:
            # Ensure proper URL format
            if not url.startswith(('http://', 'https://')):
                url = f"https://{url}"
            
            # Check for common security headers
            response = requests.get(url, timeout=10, headers={'User-Agent': self.user_agents[0]})
            headers = response.headers
            
            # Check security headers
            security_headers = {
                'X-Frame-Options': headers.get('X-Frame-Options', 'Missing'),
                'X-Content-Type-Options': headers.get('X-Content-Type-Options', 'Missing'),
                'X-XSS-Protection': headers.get('X-XSS-Protection', 'Missing'),
                'Strict-Transport-Security': headers.get('Strict-Transport-Security', 'Missing'),
                'Content-Security-Policy': headers.get('Content-Security-Policy', 'Missing')
            }
            
            for header, value in security_headers.items():
                if value == 'Missing':
                    vuln = {
                        'type': 'Missing Security Header',
                        'severity': 'Medium',
                        'description': f'Missing {header} security header',
                        'url': url,
                        'details': f'The {header} header is missing, which could lead to security vulnerabilities'
                    }
                    with self.lock:
                        self.vulnerabilities.append(vuln)
            
            # Check for server information disclosure
            server_header = headers.get('Server', '')
            if server_header and 'Apache' in server_header or 'nginx' in server_header or 'IIS' in server_header:
                vuln = {
                    'type': 'Server Information Disclosure',
                    'severity': 'Low',
                    'description': 'Server version disclosed in HTTP headers',
                    'url': url,
                    'details': f'Server information: {server_header}'
                }
                with self.lock:
                    self.vulnerabilities.append(vuln)
            
            print(f"{Fore.GREEN}[SCAN] Web security headers checked{Style.RESET_ALL}")
            
        except Exception as e:
            print(f"{Fore.RED}[ERROR] Web vulnerability scan failed: {e}{Style.RESET_ALL}")
    
    def scan_sql_injection(self, url):
        """Scan for SQL injection vulnerabilities"""
        try:
            # Basic SQL injection testing
            sql_payloads = [
                "'", '"', "' OR '1'='1", '" OR "1"="1', 
                "' OR 1=1--", '" OR 1=1--', "' UNION SELECT NULL--"
            ]
            
            # Test common parameters
            test_params = ['id', 'page', 'search', 'q', 'user', 'username', 'email']
            
            for param in test_params:
                for payload in sql_payloads:
                    test_url = f"{url.rstrip('/')}/test.php?{param}={payload}"
                    try:
                        response = requests.get(test_url, timeout=5)
                        
                        # Check for SQL error patterns
                        sql_errors = [
                            'mysql_fetch_array', 'ORA-', 'Microsoft OLE DB Provider',
                            'ODBC SQL Server Driver', 'PostgreSQL query failed',
                            'supplied argument is not a valid MySQL result',
                            'You have an error in your SQL syntax'
                        ]
                        
                        for error in sql_errors:
                            if error.lower() in response.text.lower():
                                vuln = {
                                    'type': 'SQL Injection',
                                    'severity': 'High',
                                    'description': f'Potential SQL injection in parameter {param}',
                                    'url': test_url,
                                    'parameter': param,
                                    'payload': payload,
                                    'details': f'SQL error detected: {error}'
                                }
                                with self.lock:
                                    self.vulnerabilities.append(vuln)
                                break
                    except:
                        pass
            
            print(f"{Fore.GREEN}[SCAN] SQL injection tests completed{Style.RESET_ALL}")
            
        except Exception as e:
            print(f"{Fore.RED}[ERROR] SQL injection scan failed: {e}{Style.RESET_ALL}")
    
    def scan_xss(self, url):
        """Scan for Cross-Site Scripting (XSS) vulnerabilities"""
        try:
            xss_payloads = [
                '<script>alert("XSS")</script>',
                '<img src=x onerror=alert("XSS")>',
                'javascript:alert("XSS")',
                '<svg onload=alert("XSS")>',
                '"><script>alert("XSS")</script>',
                '\'><script>alert("XSS")</script>'
            ]
            
            # Test common input parameters
            test_params = ['name', 'email', 'comment', 'search', 'q', 'message']
            
            for param in test_params:
                for payload in xss_payloads:
                    test_url = f"{url.rstrip('/')}/test.php?{param}={payload}"
                    try:
                        response = requests.get(test_url, timeout=5)
                        
                        # Check if payload is reflected
                        if payload in response.text:
                            vuln = {
                                'type': 'Cross-Site Scripting (XSS)',
                                'severity': 'Medium',
                                'description': f'Potential XSS in parameter {param}',
                                'url': test_url,
                                'parameter': param,
                                'payload': payload,
                                'details': 'Payload appears to be reflected in the response'
                            }
                            with self.lock:
                                self.vulnerabilities.append(vuln)
                    except:
                        pass
            
            print(f"{Fore.GREEN}[SCAN] XSS tests completed{Style.RESET_ALL}")
            
        except Exception as e:
            print(f"{Fore.RED}[ERROR] XSS scan failed: {e}{Style.RESET_ALL}")
    
    def scan_lfi(self, url):
        """Scan for Local File Inclusion (LFI) vulnerabilities"""
        try:
            lfi_payloads = [
                '../../../etc/passwd',
                '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
                '....//....//....//etc/passwd',
                '..%2f..%2f..%2fetc%2fpasswd',
                '..%252f..%252f..%252fetc%252fpasswd'
            ]
            
            test_params = ['file', 'page', 'path', 'template', 'config']
            
            for param in test_params:
                for payload in lfi_payloads:
                    test_url = f"{url.rstrip('/')}/test.php?{param}={payload}"
                    try:
                        response = requests.get(test_url, timeout=5)
                        
                        # Check for file content indicators
                        indicators = [
                            'root:x:',  # /etc/passwd
                            '[boot loader]',  # Windows hosts file
                            '127.0.0.1',
                            'localhost'
                        ]
                        
                        for indicator in indicators:
                            if indicator in response.text:
                                vuln = {
                                    'type': 'Local File Inclusion (LFI)',
                                    'severity': 'High',
                                    'description': f'Potential LFI in parameter {param}',
                                    'url': test_url,
                                    'parameter': param,
                                    'payload': payload,
                                    'details': f'File content indicator found: {indicator}'
                                }
                                with self.lock:
                                    self.vulnerabilities.append(vuln)
                                break
                    except:
                        pass
            
            print(f"{Fore.GREEN}[SCAN] LFI tests completed{Style.RESET_ALL}")
            
        except Exception as e:
            print(f"{Fore.RED}[ERROR] LFI scan failed: {e}{Style.RESET_ALL}")
    
    def scan_directory_traversal(self, url):
        """Scan for directory traversal vulnerabilities"""
        try:
            traversal_payloads = [
                '../', '..\\', '..%2f', '..%252f', '..%c0%af', '..%c1%9c'
            ]
            
            test_params = ['path', 'dir', 'directory', 'folder', 'file']
            
            for param in test_params:
                for payload in traversal_payloads:
                    test_url = f"{url.rstrip('/')}/test.php?{param}={payload}"
                    try:
                        response = requests.get(test_url, timeout=5)
                        
                        # Check for different response indicators
                        if response.status_code == 200 and len(response.text) > 100:
                            vuln = {
                                'type': 'Directory Traversal',
                                'severity': 'High',
                                'description': f'Potential directory traversal in parameter {param}',
                                'url': test_url,
                                'parameter': param,
                                'payload': payload,
                                'details': 'Unusual response received'
                            }
                            with self.lock:
                                self.vulnerabilities.append(vuln)
                    except:
                        pass
            
            print(f"{Fore.GREEN}[SCAN] Directory traversal tests completed{Style.RESET_ALL}")
            
        except Exception as e:
            print(f"{Fore.RED}[ERROR] Directory traversal scan failed: {e}{Style.RESET_ALL}")
    
    def scan_network_vulnerabilities(self, target):
        """Scan for network-level vulnerabilities"""
        try:
            # Check for common network vulnerabilities
            
            # Check if SSH is running with weak configuration
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(3)
                result = sock.connect_ex((target, 22))
                sock.close()
                
                if result == 0:
                    vuln = {
                        'type': 'SSH Service Exposed',
                        'severity': 'Medium',
                        'description': 'SSH service (port 22) is exposed to the internet',
                        'target': target,
                        'port': 22,
                        'details': 'SSH service detected - check for weak authentication'
                    }
                    with self.lock:
                        self.vulnerabilities.append(vuln)
            except:
                pass
            
            # Check for common database ports
            db_ports = [3306, 5432, 1433, 27017, 6379]
            for port in db_ports:
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(3)
                    result = sock.connect_ex((target, port))
                    sock.close()
                    
                    if result == 0:
                        service_names = {
                            3306: 'MySQL',
                            5432: 'PostgreSQL',
                            1433: 'MSSQL',
                            27017: 'MongoDB',
                            6379: 'Redis'
                        }
                        
                        vuln = {
                            'type': f'{service_names.get(port, "Database")} Service Exposed',
                            'severity': 'High',
                            'description': f'{service_names.get(port, "Database")} service (port {port}) is exposed',
                            'target': target,
                            'port': port,
                            'details': f'Database service detected on port {port} - potential security risk'
                        }
                        with self.lock:
                            self.vulnerabilities.append(vuln)
                except:
                    pass
            
            print(f"{Fore.GREEN}[SCAN] Network vulnerabilities checked{Style.RESET_ALL}")
            
        except Exception as e:
            print(f"{Fore.RED}[ERROR] Network vulnerability scan failed: {e}{Style.RESET_ALL}")
    
    def scan_ssl_vulnerabilities(self, target):
        """Scan for SSL/TLS vulnerabilities"""
        try:
            # Ensure proper URL format
            if not target.startswith(('http://', 'https://')):
                hostname = target
            else:
                hostname = urlparse(target).hostname
            
            context = ssl.create_default_context()
            
            try:
                with socket.create_connection((hostname, 443), timeout=10) as sock:
                    with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                        cert = ssock.getpeercert()
                        
                        # Check certificate expiration
                        not_after = cert.get('notAfter')
                        if not_after:
                            import datetime
                            expiry_date = datetime.datetime.strptime(not_after, '%b %d %H:%M:%S %Y %Z')
                            if expiry_date < datetime.datetime.now():
                                vuln = {
                                    'type': 'Expired SSL Certificate',
                                    'severity': 'High',
                                    'description': 'SSL certificate has expired',
                                    'hostname': hostname,
                                    'expiry_date': str(expiry_date),
                                    'details': 'The SSL certificate has expired and is no longer valid'
                                }
                                with self.lock:
                                    self.vulnerabilities.append(vuln)
                        
                        # Check for weak cipher suites
                        cipher = ssock.cipher()
                        if cipher and 'RC4' in cipher[0] or 'DES' in cipher[0] or 'MD5' in cipher[1]:
                            vuln = {
                                'type': 'Weak SSL Cipher Suite',
                                'severity': 'Medium',
                                'description': f'Weak cipher suite detected: {cipher[0]}',
                                'hostname': hostname,
                                'cipher': cipher[0],
                                'details': 'Weak encryption algorithm may be vulnerable to attacks'
                            }
                            with self.lock:
                                self.vulnerabilities.append(vuln)
            
            except Exception as e:
                vuln = {
                    'type': 'SSL Configuration Issue',
                    'severity': 'Medium',
                    'description': 'SSL/TLS configuration issue detected',
                    'hostname': hostname,
                    'details': str(e)
                }
                with self.lock:
                    self.vulnerabilities.append(vuln)
            
            print(f"{Fore.GREEN}[SCAN] SSL vulnerabilities checked{Style.RESET_ALL}")
            
        except Exception as e:
            print(f"{Fore.RED}[ERROR] SSL vulnerability scan failed: {e}{Style.RESET_ALL}")
    
    def scan_services(self, target):
        """Scan for specific service vulnerabilities"""
        try:
            # Check for common services and their vulnerabilities
            
            # HTTP/HTTPS service detection
            services = [80, 443, 8080, 8443]
            
            for port in services:
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(3)
                    result = sock.connect_ex((target, port))
                    sock.close()
                    
                    if result == 0:
                        protocol = 'https' if port in [443, 8443] else 'http'
                        service_url = f"{protocol}://{target}:{port}"
                        
                        # Check for common web vulnerabilities
                        self.check_common_web_issues(service_url)
                except:
                    pass
            
            print(f"{Fore.GREEN}[SCAN] Service vulnerabilities checked{Style.RESET_ALL}")
            
        except Exception as e:
            print(f"{Fore.RED}[ERROR] Service vulnerability scan failed: {e}{Style.RESET_ALL}")
    
    def check_common_web_issues(self, url):
        """Check for common web application issues"""
        try:
            # Check for robots.txt
            robots_url = urljoin(url, '/robots.txt')
            try:
                response = requests.get(robots_url, timeout=5)
                if response.status_code == 200:
                    vuln = {
                        'type': 'Information Disclosure - robots.txt',
                        'severity': 'Low',
                        'description': 'robots.txt file is accessible',
                        'url': robots_url,
                        'details': 'May contain sensitive directory information'
                    }
                    with self.lock:
                        self.vulnerabilities.append(vuln)
            except:
                pass
            
            # Check for .git directory
            git_url = urljoin(url, '/.git/')
            try:
                response = requests.get(git_url, timeout=5)
                if response.status_code == 200:
                    vuln = {
                        'type': 'Git Repository Exposure',
                        'severity': 'High',
                        'description': 'Git repository directory is accessible',
                        'url': git_url,
                        'details': 'Source code may be exposed'
                    }
                    with self.lock:
                        self.vulnerabilities.append(vuln)
            except:
                pass
            
            # Check for backup files
            backup_extensions = ['.bak', '.old', '.backup', '.swp', '~']
            for ext in backup_extensions:
                backup_url = urljoin(url, f'/index{ext}')
                try:
                    response = requests.get(backup_url, timeout=5)
                    if response.status_code == 200:
                        vuln = {
                            'type': 'Backup File Exposure',
                            'severity': 'Medium',
                            'description': f'Backup file accessible: {backup_url}',
                            'url': backup_url,
                            'details': 'Backup files may contain sensitive information'
                        }
                        with self.lock:
                            self.vulnerabilities.append(vuln)
                except:
                    pass
            
        except Exception as e:
            print(f"{Fore.RED}[ERROR] Common web issue check failed: {e}{Style.RESET_ALL}")

# Example usage
if __name__ == "__main__":
    scanner = VulnerabilityScanner()
    vulnerabilities = scanner.scan("example.com")
    print(json.dumps(vulnerabilities, indent=2, default=str))